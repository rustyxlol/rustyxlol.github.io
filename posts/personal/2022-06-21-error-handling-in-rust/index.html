<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Error Handling in Rust | Rusty</title><meta name=keywords content="personal"><meta name=description content="Expressing errors, propagating them and creating custom error types."><meta name=author content><link rel=canonical href=https://rustyxlol.github.io/posts/personal/2022-06-21-error-handling-in-rust/><link crossorigin=anonymous href=/assets/css/stylesheet.e7015e36a4fd3c21b7b8b06e8b077e472a75ea786202896039c73682bdf8e9d5.css integrity="sha256-5wFeNqT9PCG3uLBuiwd+Ryp16nhiAolgOcc2gr346dU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://rustyxlol.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rustyxlol.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rustyxlol.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://rustyxlol.github.io/apple-touch-icon.png><link rel=mask-icon href=https://rustyxlol.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Error Handling in Rust"><meta property="og:description" content="Expressing errors, propagating them and creating custom error types."><meta property="og:type" content="article"><meta property="og:url" content="https://rustyxlol.github.io/posts/personal/2022-06-21-error-handling-in-rust/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-24T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-24T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Error Handling in Rust"><meta name=twitter:description content="Expressing errors, propagating them and creating custom error types."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rustyxlol.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Error Handling in Rust","item":"https://rustyxlol.github.io/posts/personal/2022-06-21-error-handling-in-rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Error Handling in Rust","name":"Error Handling in Rust","description":"Expressing errors, propagating them and creating custom error types.","keywords":["personal"],"articleBody":"I recently started learning Rust and faced my biggest obstacle: Errors.\nI’ve mostly avoided error handling because it honestly didn’t make any sense, if you’re the one writing code, then write it in a way that you won’t have to handle errors, why go the extra mile to handle them?\nTerrible. Terrible idea.\nEvery popular builtin/library that you use contains a lot of error handling mechanisms which help you decide what to do when an error is returned.\nFor example, in Rust, when you try to add {integer} and {float}, you get an error. It may not be a serious problem in other languages but Rust takes it very seriously, and rightfully so.\nThis brings me to questioning the difference between exceptions and errors, coming from Python, exceptions are basically events that disrupt the normal flow of a program.\nFor example, if you ask user for a numerical input but the user inputs a character, or a string, then you are bound to get a ValueError.\nNow exceptions can be easily handled by anticipating what may or may not happen given a certain scenario i.e., they are recoverable.\nBut errors are pesky little things that may or may not be recoverable.\nThe thing to keep in mind is, recoverable errors allow retrying an operation after perhaps reporting it. file not found error is one such example.\nUnrecoverable errors are likely due to you, trying to access an out of bounds index, that’s bad. So we would want to immediately terminate the program if that happens.\nRust requires you to acknowledge the possibility of an error and take some action before your code will compile.1\nUnrecoverable errors Rust has a macro for situations where you know that the recovery impossible or the code is faulty.\nThe panic macro essentially unwinds, i.e., going back and cleaning up.\nFor example:2\nfn main() { panic!(\"crash and burn\"); } will generate the following:\n$ cargo run Compiling panic v0.1.0 (file:///projects/panic) Finished dev [unoptimized + debuginfo] target(s) in 0.25s Running `target/debug/panic` thread 'main' panicked at 'crash and burn', src/main.rs:2:5 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace Using the RUST_BACKTRACE=1 before cargo run will provide a flow of sorts which will help you find out which one of your files caused the program to panic.\nSome other examples such as trying to access an invalid index in an array/vector will also cause the program to panic.\nNow while this is nice, where must one use this panic! macro?\nGenerally, you will use panics in development environment, that includes testing, demonstration and the like. There are methods that will panic for you, unwrap method is one such example.\n.unwrap() is “hey, I already know that this cannot fail, so just trust me”\n— dawnofmidnight3\nRecoverable Errors Hang on tight because this is a big one, and a very deep one.\nLet’s warmup with what we’ve learned so far about the Result enum and work our way up to custom error types.\nLooking at Result’s documentation, we see that it implemented as:\npub enum Result\u003cT, E\u003e { Ok(T), Err(E), } It has two variants, Ok(T) upon success and Err(E) upon failure. It essentially “contains” our results.\nLet’s check it out with a quick example4:\npub fn generate_nametag_text(name: String) -\u003e ??? { if name.len() \u003e 0 { ??? } else { ??? } } I’m sure the sentiment of the code is pretty clear, return something positive when a name is inserted and perhaps an error mentioning that no name was inserted.\nThis is the exact scenario where you would use Result.\nTo be more descriptive, let us return String upon both success and failure.\nWe could do it like so:\npub fn generate_nametag_text(name: String) -\u003e String { if name.len() \u003e 0 { return format!(\"We got a name: {}\", name); } else { return \"We did not get a name!!\".to_string(); } } While this is very nice and does the job perfectly by fulfilling our requirements, it doesn’t provide much control to the function calling generate_nametag_text, how should the calling function determine whether it was a success or a failure? By comparing the entire string?\nWhat if a developer decides that, oh no, maybe the error message had an extra ! so I should probably remove it, and the whole code breaks because it depends on that one character.\nThat is not very nice, which introduces us to Result enum, which could return an Ok if a condition was satsified, Err or an error otherwise.\nAnd so, our program can be rewritten like:\npub fn generate_nametag_text(name: String) -\u003e Result\u003cString, String\u003e { if name.len() \u003e 0 { return Ok(format!(\"We got a name: {}\", name)); } else { return Err(\"We did not get a name!!\".to_string()); } } Now the function will return a Result enum, which is essentially either Ok or Err along with the exact same message, so now the caller of generate_nametag_text doesn’t have to depend on every character of the message/string, but rather, can work with Ok and Err, which provides a lot better control than returning a measly string.\nTODO: Propagating Errors\nbasically~ use Result if you can recover, and panic! when you cannot (and for tests)\n— dawnofmidnight5\nRust Book Chapter 9: Error Handling ↩︎\nRust Book Chapter 9.1: Unrecoverable Errors with panic ↩︎\nThis quote is from dawn#4323 on Python Discord ↩︎\nThis snippet is from rustlings error handling exercise, error1.rs ↩︎\nThis quote is also from dawn#4323 on Python Discord ↩︎\n","wordCount":"905","inLanguage":"en","datePublished":"2022-06-24T00:00:00Z","dateModified":"2022-06-24T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://rustyxlol.github.io/posts/personal/2022-06-21-error-handling-in-rust/"},"publisher":{"@type":"Organization","name":"Rusty","logo":{"@type":"ImageObject","url":"https://rustyxlol.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rustyxlol.github.io/ accesskey=h title="Rusty (Alt + H)">Rusty</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rustyxlol.github.io/about/ title=About><span>About</span></a></li><li><a href=https://rustyxlol.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://rustyxlol.github.io/projects/ title=Projects><span>Projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rustyxlol.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://rustyxlol.github.io/posts/>Posts</a></div><h1 class=post-title>Error Handling in Rust</h1><div class=post-description>Expressing errors, propagating them and creating custom error types.</div><div class=post-meta><span title='2022-06-24 00:00:00 +0000 UTC'>June 24, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/rustyxlol/rustyxlol.github.io/tree/master/content/posts/personal/2022-06-21-Error-Handling-in-Rust.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#unrecoverable-errors aria-label="Unrecoverable errors">Unrecoverable errors</a></li><li><a href=#recoverable-errors aria-label="Recoverable Errors">Recoverable Errors</a></li></ul></div></details></div><div class=post-content><p>I recently started learning Rust and faced my biggest obstacle: Errors.<br>I&rsquo;ve mostly avoided error handling because it honestly didn&rsquo;t make any sense,
if you&rsquo;re the one writing code, then write it in a way that you won&rsquo;t have to
handle errors, why go the extra mile to handle them?<br>Terrible. Terrible idea.</p><p>Every popular builtin/library that you use contains a lot of error handling
mechanisms which help you decide what to do when an error is returned.</p><p>For example, in Rust, when you try to add {integer} and {float},
you get an <a href=https://doc.rust-lang.org/stable/error-index.html#E0277>error</a>.
It may not be a serious problem in other languages but Rust takes it very
seriously, and rightfully so.</p><p>This brings me to questioning the difference between exceptions and errors,
coming from Python, exceptions are basically events that disrupt the normal
flow of a program.</p><p>For example, if you ask user for a numerical input but the user inputs a character,
or a string, then you are bound to get a <code>ValueError</code>.</p><p>Now exceptions can be easily handled by anticipating what may or may not happen
given a certain scenario i.e., they are recoverable.<br>But errors are pesky little things that may or may not be recoverable.</p><p>The thing to keep in mind is, recoverable errors allow retrying an operation after
perhaps reporting it. <em>file not found</em> error is one such example.<br>Unrecoverable errors are likely due to you, trying to access an out of bounds index,
that&rsquo;s bad. So we would want to immediately terminate the program if that happens.</p><blockquote><p>Rust requires you to acknowledge the possibility of an error and take some action
before your code will compile.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p></blockquote><h2 id=unrecoverable-errors>Unrecoverable errors<a hidden class=anchor aria-hidden=true href=#unrecoverable-errors>#</a></h2><p>Rust has a macro for situations where you know that the recovery impossible or the
code is faulty.<br>The panic macro essentially unwinds, i.e., going back and cleaning up.</p><p>For example:<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    panic!(<span style=color:#e6db74>&#34;crash and burn&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>will generate the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cargo run
</span></span><span style=display:flex><span>   Compiling panic v0.1.0 <span style=color:#f92672>(</span>file:///projects/panic<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Finished dev <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.25s
</span></span><span style=display:flex><span>     Running <span style=color:#e6db74>`</span>target/debug/panic<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>thread <span style=color:#e6db74>&#39;main&#39;</span> panicked at <span style=color:#e6db74>&#39;crash and burn&#39;</span>, src/main.rs:2:5
</span></span><span style=display:flex><span>note: run with <span style=color:#e6db74>`</span>RUST_BACKTRACE<span style=color:#f92672>=</span>1<span style=color:#e6db74>`</span> environment variable to display a backtrace
</span></span></code></pre></div><p>Using the <code>RUST_BACKTRACE=1</code> before <code>cargo run</code> will provide a flow of sorts which
will help you find out which one of your files caused the program to panic.</p><p>Some other examples such as trying to access an invalid index in an array/vector will
also cause the program to panic.</p><p>Now while this is nice, where must one use this <code>panic!</code> macro?<br>Generally, you will use panics in development environment, that includes testing,
demonstration and the like. There are methods that will panic for you, <code>unwrap</code> method
is one such example.</p><blockquote><p>.unwrap() is &ldquo;hey, I already know that this cannot fail, so just trust me&rdquo;<br>— dawnofmidnight<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p></blockquote><h2 id=recoverable-errors>Recoverable Errors<a hidden class=anchor aria-hidden=true href=#recoverable-errors>#</a></h2><p>Hang on tight because this is a big one, and a very deep one.</p><p>Let&rsquo;s warmup with what we&rsquo;ve learned so far about the <code>Result</code> enum and work our way
up to custom error types.</p><p>Looking at Result&rsquo;s documentation, we see that it implemented as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> Result<span style=color:#f92672>&lt;</span>T, E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    Ok(T),
</span></span><span style=display:flex><span>    Err(E),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It has two variants, <code>Ok(T)</code> upon success and <code>Err(E)</code> upon failure. It essentially
&ldquo;contains&rdquo; our results.</p><p>Let&rsquo;s check it out with a quick example<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>generate_nametag_text</span>(name: String) -&gt; <span style=color:#f92672>???</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> name.len() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>???</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>???</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;m sure the sentiment of the code is pretty clear, return something positive when
a <code>name</code> is inserted and perhaps an error mentioning that no name was inserted.<br>This is the exact scenario where you would use <code>Result</code>.</p><p>To be more descriptive, let us return <code>String</code> upon both success and failure.<br>We could do it like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>generate_nametag_text</span>(name: String) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> name.len() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> format!(<span style=color:#e6db74>&#34;We got a name: {}&#34;</span>, name);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;We did not get a name!!&#34;</span>.to_string();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>While this is very nice and does the job perfectly by fulfilling our requirements, it
doesn&rsquo;t provide much control to the function calling <code>generate_nametag_text</code>, how should
the calling function determine whether it was a success or a failure? By comparing the
entire string?<br>What if a developer decides that, oh no, maybe the error message had an extra <code>!</code>
so I should probably remove it, and the whole code breaks because it depends on that one character.</p><p>That is not very nice, which introduces us to <code>Result</code> enum, which could return an <code>Ok</code> if
a condition was satsified, <code>Err</code> or an error otherwise.</p><p>And so, our program can be rewritten like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>generate_nametag_text</span>(name: String) -&gt; Result<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> name.len() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Ok(format!(<span style=color:#e6db74>&#34;We got a name: {}&#34;</span>, name));
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Err(<span style=color:#e6db74>&#34;We did not get a name!!&#34;</span>.to_string());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now the function will return a <code>Result</code> enum, which is essentially either
<code>Ok</code> or <code>Err</code> along with the exact same message, so now the caller of
<code>generate_nametag_text</code> doesn&rsquo;t have to depend on every character of the
message/string, but rather, can work with <code>Ok</code> and <code>Err</code>, which provides a lot better
control than returning a measly string.</p><p><strong>TODO: Propagating Errors</strong></p><blockquote><p>basically~ use Result&lt;T, E> if you can recover, and panic! when you cannot (and for tests)<br>— dawnofmidnight<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p></blockquote><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://doc.rust-lang.org/book/ch09-00-error-handling.html>Rust Book Chapter 9: Error Handling</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html#unrecoverable-errors-with-panic>Rust Book Chapter 9.1: Unrecoverable Errors with panic</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://discord.com/channels/267624335836053506/291284109232308226/987730661668454430>This quote is from dawn#4323 on Python Discord</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://github.com/rust-lang/rustlings/blob/main/exercises/error_handling/errors1.rs>This snippet is from rustlings error handling exercise, error1.rs</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://discord.com/channels/267624335836053506/291284109232308226/987730494730936351>This quote is also from dawn#4323 on Python Discord</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://rustyxlol.github.io/tags/personal/>personal</a></li></ul><nav class=paginav><a class=prev href=https://rustyxlol.github.io/posts/blind75/2022-06-24-b75-11/><span class=title>« Prev</span><br><span>LeetCode Blind 11/75: Number of 1 Bits</span></a>
<a class=next href=https://rustyxlol.github.io/posts/blind75/2022-06-24-b75-12/><span class=title>Next »</span><br><span>LeetCode Blind 12/75: Counting Bits</span></a></nav></footer></article></main><footer class=footer><span>© 2022 Rusty</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>