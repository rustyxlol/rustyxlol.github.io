<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>LeetCode Blind 5/75: Maximum Subarray | Rusty</title><meta name=keywords content="leetcode,blind75"><meta name=description content="Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum."><meta name=author content><link rel=canonical href=https://rustyxlol.github.io/posts/blind75/2022-06-18-b75-5/><link crossorigin=anonymous href=/assets/css/stylesheet.e7015e36a4fd3c21b7b8b06e8b077e472a75ea786202896039c73682bdf8e9d5.css integrity="sha256-5wFeNqT9PCG3uLBuiwd+Ryp16nhiAolgOcc2gr346dU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://rustyxlol.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rustyxlol.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rustyxlol.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://rustyxlol.github.io/apple-touch-icon.png><link rel=mask-icon href=https://rustyxlol.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:title" content="LeetCode Blind 5/75: Maximum Subarray"><meta property="og:description" content="Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum."><meta property="og:type" content="article"><meta property="og:url" content="https://rustyxlol.github.io/posts/blind75/2022-06-18-b75-5/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-18T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-18T00:00:00+00:00"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-07-16-b75-22/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-07-08-b75-21/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-07-07-b75-20/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-07-02-b75-19/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-07-01-b75-18/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-06-30-b75-17/"><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode Blind 5/75: Maximum Subarray"><meta name=twitter:description content="Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rustyxlol.github.io/posts/"},{"@type":"ListItem","position":2,"name":"LeetCode: Blind 75","item":"https://rustyxlol.github.io/posts/blind75/"},{"@type":"ListItem","position":3,"name":"LeetCode Blind 5/75: Maximum Subarray","item":"https://rustyxlol.github.io/posts/blind75/2022-06-18-b75-5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LeetCode Blind 5/75: Maximum Subarray","name":"LeetCode Blind 5\/75: Maximum Subarray","description":"Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.","keywords":["leetcode","blind75"],"articleBody":"Problem statement Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nA subarray is a contiguous part of an array.\nLink to problem\nExample 1\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6 Example 2\nInput: nums = [1] Output: 1 Example 3\nInput: nums = [5,4,-1,7,8] Output: 23 Solutions Approach 1: Cubic The first approach anyone would think of, finding the sum of ALL sub arrays.\nUnfortunately, the first implementation that I could think of was of a cubic time complexity.\nYou essentially pick an element from the array, and find the sum of every element from there.\ne.g., if [1,2,3,4] was your array you would calculate them like so\n[1] [1, 2] [1, 2, 3] [1, 2, 3, 4] [2] [2, 3] [2, 3, 4] ... Pseudocode\nstart loop from i=0 to n-1 start loop from j=i to n-1 initialize a sum variable to 0 start loop from i to j(inclusive) sum += numbers[k] if sum is more than max_sum sum is the new max_sum Implementation in Rust\nfn max_sub_array(numbers: Vec\u003ci32\u003e) -\u003e i32 { let mut max_sum = -9999; for i in 0..numbers.len() { for j in i..numbers.len() { let mut sum = 0; for k in i..j+1 { sum += numbers[k]; } if sum \u003e max_sum { max_sum = sum; } } } max_sum } Time Complexity: $O(n^3)$\nRuntime on LeetCode: Time Limit Exceeded\nApproach 2: Quadratic Very similar to the first approach, we just get rid of the k loop and replace it with a variable instead.\nStill not as efficient but far better than the first approach as it has time complexity of $O(n^2)$.\nThe idea behind this is that when we pick a subarray, in order to get the next subarray, we are adding one element that comes after the subarray.\nImplementation in Rust\nfn max_sub_array(numbers: Vec\u003ci32\u003e) -\u003e i32 { let mut max_sum = -9999; for i in 0..numbers.len() { let mut sum = 0; for j in i..numbers.len() { sum += numbers[j]; if sum \u003e max_sum { max_sum = sum; } } } max_sum } Time Complexity: $O(n^2)$\nRuntime on LeetCode: Time Limit Exceeded\nApproach 3: Kadane’s Algorithm The main idea behind Kadane’s Algorithm is that if you are at nth index, then the max subarray ending at nth index is either element at nth index or element at nth index along with the one prior to it.\nPseudocode\nset max_current and max_sum to numbers[0] begin loop from 1 to n - 1 max_current = max(numbers[i], numbers[i] + max_current) max_sum = max(max_current, max_sum) return max_sum Implementation in Rust\nfn max_sub_array(numbers:Vec\u003ci32\u003e) -\u003e i32 { let mut max_sum = numbers[0]; let mut max_current = numbers[0]; for i in 1..numbers.len() { max_current = std::cmp::max(numbers[i], max_current + numbers[i]); max_sum = std::cmp::max(max_sum, max_current); } max_sum } Time Complexity: $O(n)$\nRuntime on LeetCode: $13$ms\nResources Note: I’ve spent about 2 hours straight on this problem and have not covered various other approaches that include other dynamic programming concepts as well as an approach that utilizes divide and conquer concept.\nA lot of my time went into researching during this question because I was pretty lost after coming up with just one working approach, which was the first one and the worst one.\nI am saving a few resources here in case I decide to tackle this problem again in future with a different approach.\nFeel free to make a contribution here if you want to cover other approaches :)\nHere are the resources I used:\nCS Dojo’s Kadane Algorithm Explanation More approaches This problem on EnjoyAlgorithms, wasn’t that good but few tidbits from there can be very insightful. NeetCode’s video on this problem ","wordCount":"624","inLanguage":"en","datePublished":"2022-06-18T00:00:00Z","dateModified":"2022-06-18T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://rustyxlol.github.io/posts/blind75/2022-06-18-b75-5/"},"publisher":{"@type":"Organization","name":"Rusty","logo":{"@type":"ImageObject","url":"https://rustyxlol.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rustyxlol.github.io/ accesskey=h title="Rusty (Alt + H)">Rusty</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rustyxlol.github.io/about/ title=About><span>About</span></a></li><li><a href=https://rustyxlol.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://rustyxlol.github.io/projects/ title=Projects><span>Projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rustyxlol.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://rustyxlol.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://rustyxlol.github.io/posts/blind75/>LeetCode: Blind 75</a></div><h1 class=post-title>LeetCode Blind 5/75: Maximum Subarray</h1><div class=post-description>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</div><div class=post-meta><span title='2022-06-18 00:00:00 +0000 UTC'>June 18, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/rustyxlol/rustyxlol.github.io/tree/master/content/posts/blind75/2022-06-18-b75-5.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#problem-statement aria-label="Problem statement">Problem statement</a></li><li><a href=#solutions aria-label=Solutions>Solutions</a><ul><li><a href=#approach-1-cubic aria-label="Approach 1: Cubic">Approach 1: Cubic</a></li><li><a href=#approach-2-quadratic aria-label="Approach 2: Quadratic">Approach 2: Quadratic</a></li><li><a href=#approach-3-kadanes-algorithm aria-label="Approach 3: Kadane&amp;rsquo;s Algorithm">Approach 3: Kadane&rsquo;s Algorithm</a></li></ul></li><li><a href=#resources aria-label=Resources>Resources</a></li></ul></div></details></div><div class=post-content><h2 id=problem-statement>Problem statement<a hidden class=anchor aria-hidden=true href=#problem-statement>#</a></h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p><em>A subarray is a contiguous part of an array.</em><br><a href=https://leetcode.com/problems/maximum-subarray/><em>Link to problem</em></a></p><p><strong>Example 1</strong></p><pre tabindex=0><code>Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6
</code></pre><p><strong>Example 2</strong></p><pre tabindex=0><code>Input: nums = [1]
Output: 1
</code></pre><p><strong>Example 3</strong></p><pre tabindex=0><code>Input: nums = [5,4,-1,7,8]
Output: 23
</code></pre><hr><h2 id=solutions>Solutions<a hidden class=anchor aria-hidden=true href=#solutions>#</a></h2><h3 id=approach-1-cubic>Approach 1: Cubic<a hidden class=anchor aria-hidden=true href=#approach-1-cubic>#</a></h3><p>The first approach anyone would think of, finding the sum of ALL sub arrays.<br>Unfortunately, the first implementation that I could think of was of a cubic time complexity.</p><p>You essentially pick an element from the array, and find the sum of every element from there.<br>e.g., if [1,2,3,4] was your array you would calculate them like so</p><pre tabindex=0><code>[1]
[1, 2]
[1, 2, 3]
[1, 2, 3, 4]
[2]
[2, 3]
[2, 3, 4]
...
</code></pre><p><strong>Pseudocode</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>start loop from i=0 to n-1
</span></span><span style=display:flex><span>    start loop from j=i to n-1
</span></span><span style=display:flex><span>        initialize a sum variable to 0
</span></span><span style=display:flex><span>        start loop from i to j(inclusive)
</span></span><span style=display:flex><span>            sum += numbers[k]
</span></span><span style=display:flex><span>        if sum is more than max_sum
</span></span><span style=display:flex><span>            sum is the new max_sum
</span></span></code></pre></div><p><strong>Implementation in Rust</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>max_sub_array</span>(numbers: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> max_sum <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>9999</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> i<span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> k <span style=color:#66d9ef>in</span> i<span style=color:#f92672>..</span>j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                sum <span style=color:#f92672>+=</span> numbers[k];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> sum <span style=color:#f92672>&gt;</span> max_sum {
</span></span><span style=display:flex><span>                max_sum <span style=color:#f92672>=</span> sum;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    max_sum
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time Complexity: $O(n^3)$<br>Runtime on LeetCode: <a href=https://leetcode.com/submissions/detail/724877256/>Time Limit Exceeded</a></p><hr><h3 id=approach-2-quadratic>Approach 2: Quadratic<a hidden class=anchor aria-hidden=true href=#approach-2-quadratic>#</a></h3><p>Very similar to the first approach, we just get rid of the <code>k</code> loop and replace it with a variable instead.<br>Still not as efficient but far better than the first approach as it has time complexity of $O(n^2)$.</p><p>The idea behind this is that when we pick a subarray, in order to get the next subarray, we are adding one element that comes after the subarray.</p><p><strong>Implementation in Rust</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>max_sub_array</span>(numbers: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> max_sum <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>9999</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> i<span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>                sum <span style=color:#f92672>+=</span> numbers[j];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> sum <span style=color:#f92672>&gt;</span> max_sum {
</span></span><span style=display:flex><span>                    max_sum <span style=color:#f92672>=</span> sum;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    max_sum
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time Complexity: $O(n^2)$<br>Runtime on LeetCode: <a href=https://leetcode.com/submissions/detail/724947451/>Time Limit Exceeded</a></p><hr><h3 id=approach-3-kadanes-algorithm>Approach 3: Kadane&rsquo;s Algorithm<a hidden class=anchor aria-hidden=true href=#approach-3-kadanes-algorithm>#</a></h3><p>The main idea behind Kadane&rsquo;s Algorithm is that if you are at nth index, then the max subarray ending at nth index is either
element at nth index or element at nth index along with the one prior to it.</p><p><strong>Pseudocode</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>set max_current and max_sum to numbers[0]
</span></span><span style=display:flex><span>begin loop from 1 to n - 1
</span></span><span style=display:flex><span>    max_current = max(numbers[i], numbers[i] + max_current)
</span></span><span style=display:flex><span>    max_sum = max(max_current, max_sum)
</span></span><span style=display:flex><span>return max_sum
</span></span></code></pre></div><p><strong>Implementation in Rust</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>max_sub_array</span>(numbers:Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> max_sum <span style=color:#f92672>=</span> numbers[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> max_current <span style=color:#f92672>=</span> numbers[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>        max_current <span style=color:#f92672>=</span> std::cmp::max(numbers[i], max_current <span style=color:#f92672>+</span> numbers[i]);
</span></span><span style=display:flex><span>        max_sum <span style=color:#f92672>=</span> std::cmp::max(max_sum, max_current);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    max_sum
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time Complexity: $O(n)$<br>Runtime on LeetCode: $13$ms</p><hr><h2 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h2><blockquote><p><strong>Note:</strong> I&rsquo;ve spent about 2 hours straight on this problem and have not covered various other approaches that include
other dynamic programming concepts as well as an approach that utilizes divide and conquer concept.</p></blockquote><p>A lot of my time went into researching during this question because I was pretty lost after coming up with
just one working approach, which was the first one and the worst one.</p><p>I am saving a few resources here in case I decide to tackle this problem again in future with a different approach.<br>Feel free to make a contribution <a href=https://github.com/rustyxlol/rustyxlol.github.io/tree/master/content/posts/blind75>here</a> if you want to cover other approaches :)</p><p>Here are the resources I used:</p><ol><li><a href="https://www.youtube.com/watch?v=86CQq3pKSUw">CS Dojo&rsquo;s Kadane Algorithm Explanation</a></li><li><a href=https://leetcode.com/problems/maximum-subarray/discuss/1595195/C%2B%2BPython-7-Simple-Solutions-w-Explanation-or-Brute-Force-%2B-DP-%2B-Kadane-%2B-Divide-and-Conquer>More approaches</a></li><li><a href=https://www.enjoyalgorithms.com/blog/maximum-subarray-sum>This problem on EnjoyAlgorithms</a>, wasn&rsquo;t that good but few tidbits from there can be very insightful.</li><li><a href=https://youtu.be/5WZl3MMT0Eg>NeetCode&rsquo;s video on this problem</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://rustyxlol.github.io/tags/leetcode/>leetcode</a></li><li><a href=https://rustyxlol.github.io/tags/blind75/>blind75</a></li></ul><nav class=paginav><a class=prev href=https://rustyxlol.github.io/posts/blind75/2022-06-17-b75-4/><span class=title>« Prev</span><br><span>LeetCode Blind 4/75: Product of Array Except Self</span></a>
<a class=next href=https://rustyxlol.github.io/posts/blind75/2022-06-20-b75-6/><span class=title>Next »</span><br><span>LeetCode Blind 6/75: Maximum Product Subarray</span></a></nav></footer></article></main><footer class=footer><span>© 2022 Rusty</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>