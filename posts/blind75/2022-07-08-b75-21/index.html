<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>LeetCode Blind 21/75: House Robber | Rusty</title><meta name=keywords content="leetcode,blind75"><meta name=description content="Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police."><meta name=author content><link rel=canonical href=https://rustyxlol.github.io/posts/blind75/2022-07-08-b75-21/><link crossorigin=anonymous href=/assets/css/stylesheet.c34d6146d0e0c8789280cec18b718bb645611d6b6c7b584914b560be0a1d1b47.css integrity="sha256-w01hRtDgyHiSgM7Bi3GLtkVhHWtse1hJFLVgvgodG0c=" rel="preload stylesheet" as=style><link rel=icon href=https://rustyxlol.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rustyxlol.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rustyxlol.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://rustyxlol.github.io/apple-touch-icon.png><link rel=mask-icon href=https://rustyxlol.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://rustyxlol.github.io/posts/blind75/2022-07-08-b75-21/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://rustyxlol.github.io/posts/blind75/2022-07-08-b75-21/"><meta property="og:site_name" content="Rusty"><meta property="og:title" content="LeetCode Blind 21/75: House Robber"><meta property="og:description" content="Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-08T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-08T00:00:00+00:00"><meta property="article:tag" content="Leetcode"><meta property="article:tag" content="Blind75"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-07-16-b75-22/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-07-07-b75-20/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-07-02-b75-19/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-07-01-b75-18/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-06-30-b75-17/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-06-28-b75-16/"><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode Blind 21/75: House Robber"><meta name=twitter:description content="Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rustyxlol.github.io/posts/"},{"@type":"ListItem","position":2,"name":"LeetCode: Blind 75","item":"https://rustyxlol.github.io/posts/blind75/"},{"@type":"ListItem","position":3,"name":"LeetCode Blind 21/75: House Robber","item":"https://rustyxlol.github.io/posts/blind75/2022-07-08-b75-21/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LeetCode Blind 21/75: House Robber","name":"LeetCode Blind 21\/75: House Robber","description":"Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.","keywords":["leetcode","blind75"],"articleBody":"Problem statement You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nLink to problem\nExample 1\nInput: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2\nInput: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. Solutions Approach 1: Dynamic Programming This is it, this is the problem that covers everything you need to know about Dynamic Programming.\nDetermine the choices required\nIn this case, the robber has two choices, he can either rob a house he’s at or skip it.\nNow looking at the cases individually:\nCase 1: Robbing the current house\nIf the current house is to be robbed, then neither the previous nor the next house can be robbed.\nCase 2: Skipping the current house\nIf the current house is to be skipped, then either the previous house or the next house can be robbed. In order to simplify, let us stick to just one direction(i.e., the robber only goes forwards).\nDetermining which choice to pick The choice which yields the highest money must be picked, which is essentially two cases:\nCase 1: Robbing the current house: Loot of that house and the loot of next houses Case 2: Skipping the current house: Loot of the next house and the loot of next houses. But before we determine which choice to pick, let us look at how one should approach a Dynamic Programming problem Taken from this LeetCode Discussion\nFind the recurrence relation, basically a subproblem if current_house is to be robbed, then current_house - 2 can be safely robbed along with the loot from previous houses\nif current house is to be skipped, then current_house - 1 can be safely robbed along with the loot from the following houses\ni.e., rob(i) = max(rob(i - 2) + current_house_value, rob(i-1))\nDo note that in this approach, you start from the last house rather than the first.\nImplementation in Python\ndef rob(self, nums: List[int]) -\u003e int: return back_tracker(nums, len(nums)-1) def back_tracker(nums, i): if i \u003c 0: return 0 return max(back_tracker(nums, i - 2) + nums[i], back_tracker(nums, i - 1)) Time Complexity: Unsure but $O(2^n)$ would be my guess\nRuntime on LeetCode: Time Limit Exceeded\nOptimizing the first approach The drawback that previous approach has is that it re-computes certain values, we could save a lot of time if we store the computed values somewhere and use them instead.\nSimple memoization will get us very far in this case.\nImplementation in Python\ndef rob(self, nums: List[int]) -\u003e int: memo = [-1] * (len(nums) +1 ) return back_tracker(nums, len(nums)-1, memo) def back_tracker(nums, i, memo): if i \u003c 0: return 0 if memo[i] \u003e= 0: return memo[i] result = max(back_tracker(nums, i - 2, memo) + nums[i], back_tracker(nums, i - 1, memo)) memo[i] = result return result Time Complexity: $O(n)$?\nRuntime on LeetCode: $36$ms\nIterative (bottom-up) So far we’ve been starting at the last house and ending at first with maximum profits, but that is taking a toll on our robbers because they need to find out which house is the last!\nOne way we could help our robbers is by giving them a starting location.\nBasically just reversing the logic and converting the recursive function into an iterative one.\nImplementation in Python\ndef rob(self, nums: List[int]) -\u003e int: memo = [0] * (len(nums) + 1) memo[1] = nums[0] # current house for i in range(1, len(nums)): current_house = nums[i] next_house = max(memo[i], current_house + memo[i-1]) memo[i+1] = next_house return memo[len(nums)] Slight improvement We didn’t really need an entire list for memoization because we just used memo[i] and memo[i+1], so that can be boiled down to just two variables\nImplementation in Python\ndef rob(self, nums: List[int]) -\u003e int: prev_prev_house = 0 prev_house = 0 for num in nums: current_house = max(prev_prev_house + num, prev_house) prev_prev_house = prev_house prev_house = current_house return prev_house Implementation in Rust\nfn rob(nums: Vec\u003ci32\u003e) -\u003e i32 { let mut prev_prev_house = 0; let mut prev_house = 0; for num in nums.into_iter() { let current_house = std::cmp::max(prev_prev_house + num, prev_house); prev_prev_house = prev_house; prev_house = current_house; } return prev_house } Far better and far easier to digest, whew, that was a long one!\nTime Complexity: $O(n)$\nRuntime on LeetCode: $2$ms\nThat was a long one. But I feel quite confident with Dynamic Programming now so that’s a very big plus.\nHouse Robber II - Problem Statement You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nLink to problem\nExample 1\nInput: nums = [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2\nInput: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Solution This was pretty much the same problem as above but by skipping the first and last house because they’re next to each other. Which is why I did not create another post for this.\nImplementation in Rust\nfn rob(nums: Vec\u003ci32\u003e) -\u003e i32 { let skip_first = \u0026nums[1..]; let skip_last = \u0026nums[0..nums.len() - 1]; let rob_skip_first = helper(skip_first.to_vec()); let rob_skip_last = helper(skip_last.to_vec()); let max = std::cmp::max(rob_skip_first, rob_skip_last); if nums[0] \u003e max { return nums[0]; } max } fn helper(nums: Vec\u003ci32\u003e) -\u003e i32 { let mut prev_prev_house = 0; let mut prev_house = 0; for num in nums.into_iter() { let current_house = std::cmp::max(prev_prev_house + num, prev_house); prev_prev_house = prev_house; prev_house = current_house; } return prev_house } Time Complexity: $O(n)$, it’s the same problem but runs two times.\nRuntime on Leetcode: $1$ms\n","wordCount":"1137","inLanguage":"en","datePublished":"2022-07-08T00:00:00Z","dateModified":"2022-07-08T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://rustyxlol.github.io/posts/blind75/2022-07-08-b75-21/"},"publisher":{"@type":"Organization","name":"Rusty","logo":{"@type":"ImageObject","url":"https://rustyxlol.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rustyxlol.github.io/ accesskey=h title="Rusty (Alt + H)">Rusty</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rustyxlol.github.io/about/ title=About><span>About</span></a></li><li><a href=https://rustyxlol.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://rustyxlol.github.io/projects/ title=Projects><span>Projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rustyxlol.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://rustyxlol.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://rustyxlol.github.io/posts/blind75/>LeetCode: Blind 75</a></div><h1 class="post-title entry-hint-parent">LeetCode Blind 21/75: House Robber</h1><div class=post-description>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</div><div class=post-meta><span title='2022-07-08 00:00:00 +0000 UTC'>July 8, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/rustyxlol/rustyxlol.github.io/tree/master/content/posts/blind75/2022-07-08-b75-21.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#problem-statement aria-label="Problem statement">Problem statement</a></li><li><a href=#solutions aria-label=Solutions>Solutions</a><ul><li><a href=#approach-1-dynamic-programming aria-label="Approach 1: Dynamic Programming">Approach 1: Dynamic Programming</a><ul><li><a href=#find-the-recurrence-relation-basically-a-subproblem aria-label="Find the recurrence relation, basically a subproblem">Find the recurrence relation, basically a subproblem</a></li><li><a href=#optimizing-the-first-approach aria-label="Optimizing the first approach">Optimizing the first approach</a></li><li><a href=#iterative-bottom-up aria-label="Iterative (bottom-up)">Iterative (bottom-up)</a></li><li><a href=#slight-improvement aria-label="Slight improvement">Slight improvement</a></li></ul></li></ul></li><li><a href=#house-robber-ii---problem-statement aria-label="House Robber II - Problem Statement">House Robber II - Problem Statement</a><ul><li><a href=#solution aria-label=Solution>Solution</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=problem-statement>Problem statement<a hidden class=anchor aria-hidden=true href=#problem-statement>#</a></h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p><p><a href=https://leetcode.com/problems/house-robber/>Link to problem</a></p><p><strong>Example 1</strong></p><pre tabindex=0><code>Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</code></pre><p><strong>Example 2</strong></p><pre tabindex=0><code>Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
</code></pre><hr><h2 id=solutions>Solutions<a hidden class=anchor aria-hidden=true href=#solutions>#</a></h2><h3 id=approach-1-dynamic-programming>Approach 1: Dynamic Programming<a hidden class=anchor aria-hidden=true href=#approach-1-dynamic-programming>#</a></h3><p>This is it, this is the problem that covers everything you need to know about Dynamic Programming.</p><ol><li><strong>Determine the choices required</strong><br>In this case, the robber has two choices, he can either rob a house he&rsquo;s at or skip it.<br>Now looking at the cases individually:<br><strong>Case 1: Robbing the current house</strong><br>If the current house is to be robbed, then neither the previous nor the next house can be robbed.<br><strong>Case 2: Skipping the current house</strong><br>If the current house is to be skipped, then either the previous house or the next house can be robbed.</li></ol><blockquote><p>In order to simplify, let us stick to just one direction(i.e., the robber only goes forwards).</p></blockquote><ol start=2><li><strong>Determining which choice to pick</strong>
The choice which yields the highest money must be picked, which is essentially two cases:<br><strong>Case 1: Robbing the current house:</strong> Loot of that house and the loot of next houses
<strong>Case 2: Skipping the current house:</strong> Loot of the next house and the loot of next houses.</li></ol><blockquote><p>But before we determine which choice to pick, let us look at how one should approach a Dynamic Programming problem
Taken from <a href=https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.>this LeetCode Discussion</a></p></blockquote><hr><h4 id=find-the-recurrence-relation-basically-a-subproblem>Find the recurrence relation, basically a subproblem<a hidden class=anchor aria-hidden=true href=#find-the-recurrence-relation-basically-a-subproblem>#</a></h4><p><strong>if current_house is to be robbed</strong>, then <code>current_house - 2</code> can be safely robbed
along with the loot from <strong>previous houses</strong><br><strong>if current house is to be skipped</strong>, then <code>current_house - 1</code> can be safely robbed
along with the loot from the <strong>following houses</strong></p><p>i.e., <code>rob(i) = max(rob(i - 2) + current_house_value, rob(i-1))</code></p><blockquote><p>Do note that in this approach, you start from the last house rather than the first.</p></blockquote><p><strong>Implementation in Python</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rob</span>(self, nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> back_tracker(nums, len(nums)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>back_tracker</span>(nums, i):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max(back_tracker(nums, i <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>+</span> nums[i], back_tracker(nums, i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span></code></pre></div><p><strong>Time Complexity:</strong> Unsure but $O(2^n)$ would be my guess<br><strong>Runtime on LeetCode:</strong> <a href=https://leetcode.com/submissions/detail/741886846/>Time Limit Exceeded</a></p><h4 id=optimizing-the-first-approach>Optimizing the first approach<a hidden class=anchor aria-hidden=true href=#optimizing-the-first-approach>#</a></h4><p>The drawback that previous approach has is that it re-computes certain values, we could save
a lot of time if we store the computed values somewhere and use them instead.<br>Simple memoization will get us very far in this case.</p><p><strong>Implementation in Python</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rob</span>(self, nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    memo <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> (len(nums) <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> back_tracker(nums, len(nums)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, memo)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>back_tracker</span>(nums, i, memo):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> memo[i] <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> memo[i]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> max(back_tracker(nums, i <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>, memo) <span style=color:#f92672>+</span> nums[i], back_tracker(nums, i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, memo))
</span></span><span style=display:flex><span>    memo[i] <span style=color:#f92672>=</span> result
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span></code></pre></div><p><strong>Time Complexity:</strong> $O(n)$?<br><strong>Runtime on LeetCode:</strong> $36$ms</p><h4 id=iterative-bottom-up>Iterative (bottom-up)<a hidden class=anchor aria-hidden=true href=#iterative-bottom-up>#</a></h4><p>So far we&rsquo;ve been starting at the last house and ending at first with maximum profits, but that is taking
a toll on our robbers because they need to find out which house is the last!<br>One way we could help our robbers is by giving them a starting location.</p><p>Basically just reversing the logic and converting the recursive function into an iterative one.</p><p><strong>Implementation in Python</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rob</span>(self, nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    memo <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (len(nums) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    memo[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> nums[<span style=color:#ae81ff>0</span>] <span style=color:#75715e># current house</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, len(nums)):
</span></span><span style=display:flex><span>        current_house <span style=color:#f92672>=</span> nums[i]
</span></span><span style=display:flex><span>        next_house <span style=color:#f92672>=</span> max(memo[i], current_house <span style=color:#f92672>+</span> memo[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>        memo[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> next_house
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> memo[len(nums)]
</span></span></code></pre></div><h4 id=slight-improvement>Slight improvement<a hidden class=anchor aria-hidden=true href=#slight-improvement>#</a></h4><p>We didn&rsquo;t really need an entire list for memoization because we just used <code>memo[i]</code> and <code>memo[i+1]</code>, so
that can be boiled down to just two variables</p><p><strong>Implementation in Python</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rob</span>(self, nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    prev_prev_house <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    prev_house <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> nums:
</span></span><span style=display:flex><span>        current_house <span style=color:#f92672>=</span> max(prev_prev_house <span style=color:#f92672>+</span> num, prev_house)
</span></span><span style=display:flex><span>        prev_prev_house <span style=color:#f92672>=</span> prev_house
</span></span><span style=display:flex><span>        prev_house <span style=color:#f92672>=</span> current_house
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> prev_house
</span></span></code></pre></div><p><strong>Implementation in Rust</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>rob</span>(nums: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> prev_prev_house <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> prev_house <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> num <span style=color:#66d9ef>in</span> nums.into_iter() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> current_house <span style=color:#f92672>=</span> std::cmp::max(prev_prev_house <span style=color:#f92672>+</span> num, prev_house);
</span></span><span style=display:flex><span>        prev_prev_house <span style=color:#f92672>=</span> prev_house;
</span></span><span style=display:flex><span>        prev_house <span style=color:#f92672>=</span> current_house;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> prev_house
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Far better and far easier to digest, whew, that was a long one!<br>Time Complexity: $O(n)$<br>Runtime on LeetCode: $2$ms</p><blockquote><p>That was a long one. But I feel quite confident with Dynamic Programming now so that&rsquo;s a very big plus.</p></blockquote><hr><h2 id=house-robber-ii---problem-statement>House Robber II - Problem Statement<a hidden class=anchor aria-hidden=true href=#house-robber-ii---problem-statement>#</a></h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p><p><a href=https://leetcode.com/problems/house-robber-ii/>Link to problem</a></p><p><strong>Example 1</strong></p><pre tabindex=0><code>Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
</code></pre><p><strong>Example 2</strong></p><pre tabindex=0><code>Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</code></pre><h3 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h3><p>This was pretty much the same problem as above but by skipping the first and last house because they&rsquo;re next to each
other. Which is why I did not create another post for this.</p><p><strong>Implementation in Rust</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>rob</span>(nums: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> skip_first <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>nums[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> skip_last <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>nums[<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>nums.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rob_skip_first <span style=color:#f92672>=</span> helper(skip_first.to_vec());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rob_skip_last <span style=color:#f92672>=</span> helper(skip_last.to_vec());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> max <span style=color:#f92672>=</span> std::cmp::max(rob_skip_first, rob_skip_last);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> nums[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;</span> max {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> nums[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    max
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>helper</span>(nums: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> prev_prev_house <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> prev_house <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> num <span style=color:#66d9ef>in</span> nums.into_iter() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> current_house <span style=color:#f92672>=</span> std::cmp::max(prev_prev_house <span style=color:#f92672>+</span> num, prev_house);
</span></span><span style=display:flex><span>        prev_prev_house <span style=color:#f92672>=</span> prev_house;
</span></span><span style=display:flex><span>        prev_house <span style=color:#f92672>=</span> current_house;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> prev_house
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time Complexity: $O(n)$, it&rsquo;s the same problem but runs two times.<br>Runtime on Leetcode: $1$ms</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rustyxlol.github.io/tags/leetcode/>Leetcode</a></li><li><a href=https://rustyxlol.github.io/tags/blind75/>Blind75</a></li></ul><nav class=paginav><a class=prev href=https://rustyxlol.github.io/posts/blind75/2022-07-07-b75-20/><span class=title>« Prev</span><br><span>LeetCode Blind 20/75: Combination Sum IV</span>
</a><a class=next href=https://rustyxlol.github.io/posts/blind75/2022-07-16-b75-22/><span class=title>Next »</span><br><span>LeetCode Blind 22/75: Decode Ways</span></a></nav></footer></article></main><footer class=footer><span>© 2022 Rusty</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>