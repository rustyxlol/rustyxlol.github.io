<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>LeetCode Blind 4/75: Product of Array Except Self | Rusty</title><meta name=keywords content="leetcode,blind75"><meta name=description content="Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]."><meta name=author content><link rel=canonical href=https://rustyxlol.github.io/posts/blind75/2022-06-17-b75-4/><link crossorigin=anonymous href=/assets/css/stylesheet.e7015e36a4fd3c21b7b8b06e8b077e472a75ea786202896039c73682bdf8e9d5.css integrity="sha256-5wFeNqT9PCG3uLBuiwd+Ryp16nhiAolgOcc2gr346dU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://rustyxlol.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rustyxlol.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rustyxlol.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://rustyxlol.github.io/apple-touch-icon.png><link rel=mask-icon href=https://rustyxlol.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:title" content="LeetCode Blind 4/75: Product of Array Except Self"><meta property="og:description" content="Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]."><meta property="og:type" content="article"><meta property="og:url" content="https://rustyxlol.github.io/posts/blind75/2022-06-17-b75-4/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-17T17:00:00+05:30"><meta property="article:modified_time" content="2022-06-17T17:00:00+05:30"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-06-20-b75-8/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-06-20-b75-7/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-06-20-b75-6/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-06-18-b75-5/"><meta property="og:see_also" content="https://rustyxlol.github.io/posts/blind75/2022-06-17-b75-3/"><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode Blind 4/75: Product of Array Except Self"><meta name=twitter:description content="Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rustyxlol.github.io/posts/"},{"@type":"ListItem","position":2,"name":"LeetCode Blind 4/75: Product of Array Except Self","item":"https://rustyxlol.github.io/posts/blind75/2022-06-17-b75-4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LeetCode Blind 4/75: Product of Array Except Self","name":"LeetCode Blind 4\/75: Product of Array Except Self","description":"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].","keywords":["leetcode","blind75"],"articleBody":"Problem statement Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.\nLink to problem\nExample 1\nInput: nums = [1,2,3,4] Output: [24,12,8,6] Example 2\nInput: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Solutions Approach 1: Looping First approach anyone would think of, pick an element and multiply all elements except that element.\nRequires a nested loop which skyrockets the time complexity to $O(n^2)$.\nHowever, the instructions say that an algorithm must be written that has time complexity of $O(n)$ and no more.\nImplementation in Rust\nfn product_except_self(numbers: Vec\u003ci32\u003e) -\u003e Vec\u003ci32\u003e { let mut results: Vec\u003ci32\u003e = Vec::new(); for i in 0..numbers.len() { let mut product: i32 = 1; for j in 0..numbers.len() { if i != j { product = product * numbers[j]; } } results.push(product); } results } Time Complexity: $O(n^2)$\nSpace Complexity: $O(n)$\nRuntime on LeetCode: Time Limit Exceeded\nApproach 2: Division Another approach which violates the leetcode instructions is usage of division.\nThe way division works in this case is, when you multiply all numbers, you can essentially divide it by the number that you donâ€™t want, so it will run in $O(n)$ time complexity.\nThe reason this is not allowed is probably because of edge cases, such as multiplication by 0 and division by 0.\nMost of your time would be spent in tackling the edge cases.\nWould you like to make a contribution and add Rust implementation here?\nTime complexity: $O(n)$\nApproach 3: Before and After self In this approach, we basically multiply the elements prior to self and after self.\nTook me way too long to figure it out but it was worth it in the end.\nThe procedure is somewhat like this:\nCreate pre, post and result vectors Initialize pre and post vectors with 1, their length must be same as input array For the pre vector Start iteration from the FIRST index, because the 0th index will be 1, always. Since there are no elements prior to 0th index element, we keep it at 1. Assign the product of previous number and the previous element in pre to the current pre element. For the post vector Start iteration from the SECOND LAST index, because there are no elements after the last index, we keep that at 1. While moving backwards, assign the product of next number and next element in the post vector to the current post element. Pseudocode\ncreate vector result create vector pre of input array's length create vector post of input array's length begin loop from 1 till end of input array's length assign pre[i-1] * numbers[i-1] to pre[i] begin loop from input array's length - 1 till 0 assign post[i+1] * numbers[i+1] to post[i] begin loop from 0 till input array's length push post[i] * pre[i] to results return results Implementation in Rust\nfn product_except_self(numbers: Vec\u003ci32\u003e) -\u003e Vec\u003ci32\u003e { let mut results: Vec\u003ci32\u003e = Vec::new(); let mut pre = vec![1; numbers.len()]; let mut post = vec![1; numbers.len()]; for i in 1..numbers.len() { pre[i] = (numbers[i-1] * pre[i-1]); } for i in (0..numbers.len() - 1).rev() { post[i] = numbers[i+1] * post[i+1]; } for i in 0..numbers.len() { results.push(pre[i] * post[i]); } results } Time Complexity: $O(n)$\nRuntime on LeetCode: $10$ms\nYou are probably thinking that the above could be improved by getting rid of pre and post vectors and working solely with results vector, which is an extra challenge that LeetCode mentioned at the end. Your thoughts are 100% valid. This can be done using just the results vector and another variable to manage post values.\nImplementation in Rust\nfn product_except_self(numbers: Vec\u003ci32\u003e) -\u003e Vec\u003ci32\u003e { let mut pre = vec![1; numbers.len()]; let mut post_op: i32 = 1; for i in 1..numbers.len() { pre[i] = (numbers[i-1] * pre[i-1]); } for i in (0..numbers.len()).rev() { pre[i] = post_op * pre[i]; post_op *= numbers[i]; } pre } Time Complexity: $O(n)$\nSpace Complexity: $O(1)$ according to LeetCode challenge since the results array is not considered.\nRuntime on LeetCode: $15$ms\n","wordCount":"703","inLanguage":"en","datePublished":"2022-06-17T17:00:00+05:30","dateModified":"2022-06-17T17:00:00+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://rustyxlol.github.io/posts/blind75/2022-06-17-b75-4/"},"publisher":{"@type":"Organization","name":"Rusty","logo":{"@type":"ImageObject","url":"https://rustyxlol.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rustyxlol.github.io/ accesskey=h title="Rusty (Alt + H)">Rusty</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rustyxlol.github.io/about/ title=About><span>About</span></a></li><li><a href=https://rustyxlol.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://rustyxlol.github.io/projects/ title=Projects><span>Projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rustyxlol.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://rustyxlol.github.io/posts/>Posts</a></div><h1 class=post-title>LeetCode Blind 4/75: Product of Array Except Self</h1><div class=post-description>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</div><div class=post-meta><span title='2022-06-17 17:00:00 +0530 +0530'>June 17, 2022</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#problem-statement aria-label="Problem statement">Problem statement</a></li><li><a href=#solutions aria-label=Solutions>Solutions</a><ul><li><a href=#approach-1-looping aria-label="Approach 1: Looping">Approach 1: Looping</a></li><li><a href=#approach-2-division aria-label="Approach 2: Division">Approach 2: Division</a></li><li><a href=#approach-3-before-and-after-self aria-label="Approach 3: Before and After self">Approach 3: Before and After self</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=problem-statement>Problem statement<a hidden class=anchor aria-hidden=true href=#problem-statement>#</a></h2><p>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</p><p>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p><p><em><strong>You must write an algorithm that runs in O(n) time and without using the division operation.</strong></em><br><a href=https://leetcode.com/problems/product-of-array-except-self/><em>Link to problem</em></a></p><p><strong>Example 1</strong></p><pre tabindex=0><code>Input: nums = [1,2,3,4]
Output: [24,12,8,6]
</code></pre><p><strong>Example 2</strong></p><pre tabindex=0><code>Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
</code></pre><hr><h2 id=solutions>Solutions<a hidden class=anchor aria-hidden=true href=#solutions>#</a></h2><h3 id=approach-1-looping>Approach 1: Looping<a hidden class=anchor aria-hidden=true href=#approach-1-looping>#</a></h3><p>First approach anyone would think of, pick an element and multiply all elements except that element.<br>Requires a nested loop which skyrockets the time complexity to $O(n^2)$.</p><p>However, the instructions say that an algorithm must be written that has time complexity of $O(n)$ and no more.</p><p><strong>Implementation in Rust</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>product_except_self</span>(numbers: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> results: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> product: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> i <span style=color:#f92672>!=</span> j {
</span></span><span style=display:flex><span>                product <span style=color:#f92672>=</span> product <span style=color:#f92672>*</span> numbers[j];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        results.push(product);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    results
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time Complexity: $O(n^2)$<br>Space Complexity: $O(n)$<br>Runtime on LeetCode: <a href=https://leetcode.com/submissions/detail/724376020/>Time Limit Exceeded</a></p><hr><h3 id=approach-2-division>Approach 2: Division<a hidden class=anchor aria-hidden=true href=#approach-2-division>#</a></h3><p>Another approach which violates the leetcode instructions is usage of division.</p><p>The way division works in this case is, when you multiply all numbers, you can essentially divide it by
the number that you don&rsquo;t want, so it will run in $O(n)$ time complexity.</p><p>The reason this is not allowed is probably because of edge cases, such as multiplication by 0 and division by 0.</p><p>Most of your time would be spent in tackling the edge cases.<br><a href=https://github.com/rustyxlol/rustyxlol.github.io/tree/master/content/posts/blind75><em>Would you like to make a contribution and add Rust implementation here?</em></a></p><p>Time complexity: $O(n)$</p><hr><h3 id=approach-3-before-and-after-self>Approach 3: Before and After self<a hidden class=anchor aria-hidden=true href=#approach-3-before-and-after-self>#</a></h3><p>In this approach, we basically multiply the elements prior to self and after self.<br>Took me way too long to figure it out but it was worth it in the end.</p><p>The procedure is somewhat like this:</p><ol><li>Create pre, post and result vectors</li><li>Initialize pre and post vectors with 1, their length must be same as input array</li><li>For the <code>pre</code> vector<ol><li>Start iteration from the FIRST index, because the 0th index will be 1, always. Since there are no elements prior to 0th index element, we keep it at 1.</li><li>Assign the product of previous number and the previous element in <code>pre</code> to the current <code>pre</code> element.</li></ol></li><li>For the <code>post</code> vector<ol><li>Start iteration from the SECOND LAST index, because there are no elements after the last index, we keep that at <strong>1</strong>.</li><li>While moving backwards, assign the product of next number and next element in the <code>post</code> vector to the current <code>post</code> element.</li></ol></li></ol><p><strong>Pseudocode</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>create vector result 
</span></span><span style=display:flex><span>create vector pre of input array&#39;s length
</span></span><span style=display:flex><span>create vector post of input array&#39;s length
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>begin loop from 1 till end of input array&#39;s length
</span></span><span style=display:flex><span>    assign pre[i-1] * numbers[i-1] to pre[i]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>begin loop from input array&#39;s length - 1 till 0
</span></span><span style=display:flex><span>    assign post[i+1] * numbers[i+1] to post[i]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>begin loop from 0 till input array&#39;s length
</span></span><span style=display:flex><span>    push post[i] * pre[i] to results
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>return results
</span></span></code></pre></div><p><strong>Implementation in Rust</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>product_except_self</span>(numbers: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> results: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> pre <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>1</span>; numbers.len()];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> post <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>1</span>; numbers.len()];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>        pre[i] <span style=color:#f92672>=</span> (numbers[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> pre[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>numbers.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>).rev() {
</span></span><span style=display:flex><span>        post[i] <span style=color:#f92672>=</span> numbers[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> post[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>        results.push(pre[i] <span style=color:#f92672>*</span> post[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    results
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time Complexity: $O(n)$<br>Runtime on LeetCode: $10$ms</p><p>You are probably thinking that the above could be improved by getting rid of pre and post vectors and working
solely with results vector, which is an extra challenge that LeetCode mentioned at the end. Your thoughts are
100% valid. This can be done using just the results vector and another variable to manage post values.</p><p><strong>Implementation in Rust</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>product_except_self</span>(numbers: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> pre <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>1</span>; numbers.len()];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> post_op: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>        pre[i] <span style=color:#f92672>=</span> (numbers[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> pre[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>numbers.len()).rev() {
</span></span><span style=display:flex><span>        pre[i] <span style=color:#f92672>=</span> post_op <span style=color:#f92672>*</span> pre[i];
</span></span><span style=display:flex><span>        post_op <span style=color:#f92672>*=</span> numbers[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pre
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time Complexity: $O(n)$<br>Space Complexity: $O(1)$ <em>according to LeetCode challenge since the results array is not considered</em>.<br>Runtime on LeetCode: $15$ms</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rustyxlol.github.io/tags/leetcode/>leetcode</a></li><li><a href=https://rustyxlol.github.io/tags/blind75/>blind75</a></li></ul><nav class=paginav><a class=prev href=https://rustyxlol.github.io/posts/blind75/2022-06-17-b75-3/><span class=title>Â« Prev</span><br><span>LeetCode Blind 3/75: Contains Duplicates</span></a>
<a class=next href=https://rustyxlol.github.io/posts/blind75/2022-06-18-b75-5/><span class=title>Next Â»</span><br><span>LeetCode Blind 5/75: Maximum Subarray</span></a></nav></footer></article></main><footer class=footer><span>Â© 2022 Rusty</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>